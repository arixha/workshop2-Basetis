<!-- Code from d3-graph-gallery.com -->
<!DOCTYPE html>
<meta charset="utf-8">

<head>
	<title>D3 Network</title>
	<meta charset="utf-8">

</head>
<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.js"></script>

<body>

<!-- Create a div where the graph will take place -->
<!-- <select id="json_sources" name="json_sources">
  <option value ="secondNetwork.json" selected>secondNetwork.json</option>
  <option value ="subset_reversed.json">subset_reversed.json</option>
  <option value ="subset_smaller.json">subset_smaller.json</option>
  <option value ="subset.json">subset.json</option>
  <option value ="subset1.json">subset1.json</option>
  <option value ="data.json">data.json</option>
</select>â€‹ -->
<div id="graph"></div>


<script>

// set the dimensions and margins of the graph
const width = 800;
const height = 800;
const sizes = [16, 8, 4]
const types = ['Topic', 'Authors', 'Organizations', 'TwitterAccount', 'Tweet', 'Publication', 'ClinicalTrial', 'Product'];
const relationships = ['mentions', 'tweets', 'replies', 'retweets', 'quotes', 'worksOn', 'hasProduct', 'isSponsor', 'isAuthor', 'cites', 'isAffiliated'];
const lineWeights = [0.5, 0.5, 0.5, 1, 1, 2, 1, 1, 1, 0.5, 1]
const colors = ['#ec4977', '#fe7069', '#ff9863', '#28dfce', '#00cceb', '#0cb4f5', '#ffbe6b', '#ffe382', '#d8f496', '#8cedad']
const strengths = [-100, -70, -70, -70, 10, 10, 10, 10]
// const bodyScale = d3.scaleOrdinal(sizes);
const colorScale = d3.scaleOrdinal(colors);
const levels = [0, 1, 2]


//// FUNS ////
function lineWeight() {
  const scale = d3.scaleOrdinal().domain(relationships).range(lineWeights);
  return d => scale(d.label)
}
function size() {
  const scale = d3.scaleOrdinal().domain(levels).range(sizes);
  return d => scale(d.level)
}
function color() {
  const scale = d3.scaleOrdinal().domain(relationships).range(colors);
  return d => scale(d.label);
}
function strength() {
  const scale = d3.scaleOrdinal().domain(types).range(strengths);
  return d => scale(d.labels[0])
}

// drag function for simulation
drag = simulation => {
    function dragstarted(event) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      event.subject.fx = event.subject.x;
      event.subject.fy = event.subject.y;
    }
    function dragged(event) {
      event.subject.fx = event.x;
      event.subject.fy = event.y;
    }
    function dragended(event) {
      if (!event.active) simulation.alphaTarget(0);
      event.subject.fx = null;
      event.subject.fy = null;
    }
    return d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended);
}


function getProps(node) {
  if (node.labels[0] == "Topic") {
    return {
      Term: node.properties.term,
      Description: node.properties.description,
      Sentiment: node.properties.last_sentiment_score
    }
  }
  if (node.labels[0] == "Author") {
    return {
      Name: node.properties.name,
      H_index: node.properties.h_index,
      Publications: node.properties.num_publications
    }
  }
  if (node.labels[0] == "Organization") {
    return {
      Name: node.properties.name,
      Trials: node.properties.num_cts
    }
  }
  if (node.labels[0] == "TwitterAccount") {
    return {
      Name: node.properties.name,
      Followers: node.properties.followers,
      Following: node.properties.following
    }
  }
  if (node.labels[0] == "Tweet") {
    return {
      Tweet: node.properties.text,
      Retweets: node.properties.retweets,
      Favorites: node.properties.favourites,
      Sentiment: node.properties.sentiment
    }
  }
  if (node.labels[0] == "Publication") {
    return {
      PMID: node.properties.pmid,
      Published: new Date(node.properties.publication_date*1000)
    }
  }
  if (node.labels[0] == "ClinicalTrial") {
    return {
      ID: node.properties.clinicaltrial_id,
      Started: node.properties.start_date
    }
  }
  if (node.labels[0] == "Product") {
    return {
      Name: node.properties.substance_name,
      Generic: node.properties.generic_name,
      BrandName: node.properties.brand_name,
      Type: node.properties.product_type
    }
  }
}

function linkScale(link) {
  if (link.label == 'worksOn') {
    return 150;
  } else {
    return 30;
  }
}

function table(data){ 
    let cols = Object.keys(data);
    //console.log(cols)
    let nameRow = cols  
      .map(col => `<th>${col}</th>`)
      .join("");
    let rows = [data]
      .map(row => {
        let tds = cols.map(col => `<tr><td><b>${col} </b>: 
          ${row[col]} </td></tr>`).join("");
       return `${tds}`;
      })
      .join("");
      const table = `
    <table>
      <tbody>
        ${rows}
      <tbody>
    <table>`;
    // const table = `
    // <table>
    //    <thead>
    //    <tr>${nameRow}</tr>
    //    <thead>
    //   <tbody>
    //     ${rows}
    //   <tbody>
    // <table>`;

    return table;
  };
//////////////

//// viz ////
/// selector

/// data
//d3.json('https://raw.githubusercontent.com/arixha/workshop2-Basetis/sara-testing/data.json').then ( data => { // full data
//d3.json('https://raw.githubusercontent.com/arixha/workshop2-Basetis/sara-testing/filtered_data.json').then ( data => { // more diverse data, doesn't work right now!
//d3.json('https://raw.githubusercontent.com/arixha/workshop2-Basetis/sara-testing/filtered_data_moreNodes.json').then ( data => { // only twitter data
//d3.json('https://raw.githubusercontent.com/arixha/workshop2-Basetis/sara-testing/miserables.json').then ( data => { // fake data
d3.json('https://raw.githubusercontent.com/arixha/workshop2-Basetis/main/subset_reversed.json').then ( data => {

  // d3.json('subset_reversed.json').then ( data => {
    const links = data.links.map(d => Object.create(d));
    const nodes = data.nodes.map(d => Object.create(d));

    
    // const linkScale = d3.scaleLinear().domain(d3.extent(data.links.map(d => d.score))).range([100, 450]);
    // const bodyScale = d3.scaleLinear().domain(d3.extent(data.links.map(d => d.score))).range([-70, 10]);

    // console.log(nodes)
    // console.log(links)
  
    // append the svg object to the body of the page
    var svg = d3.select("#graph")
      .append('svg')
      .attr('viewBox', [0, 0, width, height])
      
    svg
      .append("rect")
      // .attr("width", "100%")
      .attr("height", "100%")
      .attr("fill", "#f5f5f5");
    
  
    // console.log(d3.extent(data.links.map(d => d.score)))

    // console.log(data.nodes)
    // console.log(data.links)
    // console.log(linkScale(.9))
    //console.log(bodyScale(0))

    const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(d => data.links.hasOwnProperty('score') ? linkScale(links) : 30))
        // .force("charge", d3.forceManyBody().strength(d => data.links.hasOwnProperty('score') ? bodyScale(data.links[d.id].score) : -50))
        .force("charge", d3.forceManyBody().strength(-50))//.strength(d => data.nodes.hasOwnProperty('labels') ? strength(data.nodes[d.id]) : -30))
        .force("center", d3.forceCenter(width / 2, height / 2));

    const link = svg.append("g")
      .attr("stroke-opacity", 1)
      .selectAll("line")
      .data(links)
      .join("line")
        .attr("stroke-width", lineWeight(links))
        .attr("stroke", color(links));

    const tooltip = d3
      .select('body')
      .append('div')
      .attr('id', 'tooltip')
      .style("font-family", "'Proxima Nova', sans-serif")
      .style('position', 'absolute')
      .style('z-index', '1')
      .style('visibility', 'hidden')
      .style('padding', '10px')
      .style('background', 'rgba(0,0,0,0.5)')
      .style('font-size', '13px')
      .style('border-radius', '4px')
      .style('color', '#fff');

    const node = svg.append("g")
        .attr("stroke", "#fff")
        .attr("stroke-width", 2)
      .selectAll("circle")
      .data(nodes)
      .join("circle")
        .attr("r", size(nodes))
        .attr("fill", "#000")//d => colorScale(d.labels[0])) 
        .attr("fill-opacity","0.6")
        .call(drag(simulation))
        
        // Interaction [tooltip, highlights]
        .on("mouseover", function(e, d, i) {
          let tooltipWidth = tooltip.node().offsetWidth;
          let tooltipHeight = tooltip.node().offsetHeight;
          const content = new Array(getProps(d))[0];
          const labels = [...new Set(data.nodes.map(d => d.labels[0]))];
          // console.log(d.properties)
          tooltip
            .style("left", e.pageX - tooltipWidth  + 'px')
            .style("top", e.pageY - tooltipHeight  + 'px')
            .style('visibility', 'visible').html(`<h3>${d.labels}</h3> ${table(content)}`)
            d3.select(d.target, d.source).attr("fill", "steelblue");
            d3.select(this).attr('fill-opacity', '1').attr('stroke-width', 0.25)
          })
        .on('mousemove', function(e) {
          let tooltipWidth = tooltip.node().offsetWidth;
          let tooltipHeight = tooltip.node().offsetHeight;
          tooltip
            .style("left", e.pageX - tooltipWidth / 2 + 'px')
            .style("top", e.pageY - tooltipHeight - 10 + 'px');
        })

        .on("mouseout", function(e, d) {
          tooltip.style('visibility', 'hidden');
          d3.select(this)
          .attr("fill", "#000")
          .style("fill-opacity","0.6")
        });

    d3.zoom().on("zoom", (event) =>{ 
    node.attr("transform", event.transform),
    link.attr("transform", event.transform)})(svg);
    
    node.append("title")
        .text(d => d.id);
  
    simulation.on("tick", () => {
      link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

      node
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);
    })
  
  
  

  
  
  // utils
  // -----
  // https://observablehq.com/@sechodosh/graph
  // https://observablehq.com/@x80110/graph

  // groups
  // https://observablehq.com/@ravengao/force-directed-graph-with-cola-grouping
  // https://bl.ocks.org/bumbeishvili/f027f1b6664d048e894d19e54feeed42
  // https://bl.ocks.org/GerHobbelt/3104394 <- this one is very interesting


})

</script>
</body>